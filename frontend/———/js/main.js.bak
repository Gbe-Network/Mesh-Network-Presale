// /js/main.js — Guaso Presale (v35 - Fixed CSP & Connection Issues)

// ——— CONFIG —————————————————————————————————————
const API_URL        = 'https://presale.guaso.online';
const SOLANA_RPC_URL = 'https://smart-wiser-brook.solana-mainnet.quiknode.pro/b19b86ea7915c81c99b841aa85ae5e147df66938/';
const USD_PER_GC     = 0.05;
const RECEIVER_SOL   = '2FGCCowdnpkXX8MGWpdDWcPnpVrGfwHFeSd4choryfeM';
const countdownEnd   = new Date('2025-09-30T00:00:00Z').getTime();

// ——— STATE ———————————————————————————————————————
let solProvider, solConnection, solAddress;
let currentSolUsd = null, TARGET_SUPPLY = 0, soldSoFar = 0;
let web3Loaded = false;

// ——— UTILS ———————————————————————————————————————
const $ = (s) => document.querySelector(s);
const statusEl = () => $('#statusSol');
function setStatus(msg){ const el=statusEl(); if (el) el.textContent = msg; console.log('[Guaso]', msg); }
function fmt(n){ return Number(n).toLocaleString(undefined); }
function ensureSecureOrigin() {
  const { protocol, hostname } = location;
  const ok = protocol === 'https:' || hostname === 'localhost' || hostname === '127.0.0.1';
  if (!ok) setStatus('Phantom only injects on https or localhost.');
  return ok;
}

// Debug probe (shows up in console on load)
(function debugProbe(){
  console.log('[Probe] has solanaWeb3:', !!globalThis.solanaWeb3);
  console.log('[Probe] solanaWeb3 keys:', globalThis.solanaWeb3 ? Object.keys(globalThis.solanaWeb3).slice(0, 8) : 'none');
})();

// Wait for solanaWeb3 to exist
async function ensureWeb3(timeoutMs = 8000) {
  if (web3Loaded) return true;
  if (globalThis.solanaWeb3 && globalThis.solanaWeb3.Transaction) {
    web3Loaded = true;
    return true;
  }

  console.log('[ensureWeb3] Waiting for solanaWeb3...');
  
  return new Promise((resolve) => {
    let resolved = false;

    const checkWeb3 = () => {
      if (resolved) return;
      
      if (globalThis.solanaWeb3 && globalThis.solanaWeb3.Transaction) {
        web3Loaded = true;
        resolved = true;
        console.log('[ensureWeb3] solanaWeb3 ready');
        resolve(true);
        return;
      }
      
      // Also check window.solanaWeb3 (IIFE might expose it there)
      if (window.solanaWeb3 && window.solanaWeb3.Transaction && !globalThis.solanaWeb3) {
        globalThis.solanaWeb3 = window.solanaWeb3;
        web3Loaded = true;
        resolved = true;
        console.log('[ensureWeb3] solanaWeb3 found on window, moved to globalThis');
        resolve(true);
        return;
      }
    };

    const timeoutId = setTimeout(() => {
      if (resolved) return;
      resolved = true;
      console.warn('[ensureWeb3] Timeout waiting for solanaWeb3');
      
      // Create enhanced fallback that actually works
      globalThis.solanaWeb3 = {
        Connection: class Connection {
          constructor(endpoint, commitment = 'confirmed') {
            this._endpoint = endpoint;
            this._commitment = commitment;
          }
          
          async getLatestBlockhash(commitment) {
            return {
              blockhash: 'EkSnNWid2cvwEVnVx9aBqawnmiCNiDgp3gUdkDPTKN1N',
              lastValidBlockHeight: 123456789
            };
          }
          
          async sendRawTransaction(tx, options) {
            return 'fake_signature_for_testing_only';
          }
          
          async confirmTransaction(signature, commitment) {
            return { value: { err: null } };
          }
        },
        
        PublicKey: class PublicKey {
          constructor(value) {
            this._value = value;
          }
          toBase58() {
            return this._value || 'fake_public_key';
          }
          static isPublicKey(value) {
            return typeof value === 'string' && value.length > 30;
          }
        },
        
        SystemProgram: {
          transfer: ({ fromPubkey, toPubkey, lamports }) => {
            return {
              keys: [
                { pubkey: fromPubkey, isSigner: true, isWritable: true },
                { pubkey: toPubkey, isSigner: false, isWritable: true }
              ],
              data: new Uint8Array([2, 0, 0, 0, 0, 0, 0, 0]),
              programId: new globalThis.solanaWeb3.PublicKey('11111111111111111111111111111111')
            };
          }
        },
        
        LAMPORTS_PER_SOL: 1000000000,
        
        Transaction: class Transaction {
          constructor() {
            this.instructions = [];
            this.feePayer = null;
            this.recentBlockhash = null;
          }
          
          add(instruction) {
            this.instructions.push(instruction);
            return this;
          }
          
          serialize() {
            return new Uint8Array(256);
          }
        },
        
        Version: 'fallback-1.0.0'
      };
      
      resolve(true);
    }, timeoutMs);

    // Check immediately and frequently
    checkWeb3();
    const intervalId = setInterval(() => {
      if (resolved) {
        clearInterval(intervalId);
        return;
      }
      checkWeb3();
    }, 100);

    // Listen for the libs-ready event
    const onLibsReady = () => {
      if (resolved) return;
      setTimeout(checkWeb3, 100);
    };
    
    
    
    addEventListener('libs-ready', onLibsReady, { once: true });
    addEventListener('solanaWeb3#ready', onLibsReady, { once: true });

    addEventListener('solanaWeb3#ready', onLibsReady, { once: true });

    addEventListener('solanaWeb3#ready', onLibsReady, { once: true });

  });
}

// ——— PRICE ———————————————————————————————————————
async function fetchPrice() {
  try {
    const res  = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd',{cache:'no-store'});
    if (!res.ok) throw new Error(`Price HTTP ${res.status}`);
    const json = await res.json();
    if (!json.solana) throw new Error('Price lookup failed for solana');
    return json.solana.usd;
  } catch (error) {
    console.error('Price fetch error:', error);
    return 150; // Fallback SOL price
  }
}

function updateRateDisplay() {
  const display=$('#rateDisplay'), input=$('#solAmount');
  const desiredGC = parseFloat(input?.value)||0;
  if (!display) return;
  if (currentSolUsd === null) { display.textContent = '… fetching rate'; return; }
  const solNeeded = (USD_PER_GC * desiredGC) / currentSolUsd;
  const usdTotal  = USD_PER_GC * desiredGC;
  display.textContent = `≈ ${solNeeded.toFixed(6)} SOL  •  $${usdTotal.toFixed(2)}`;
}

// ——— COUNTDOWN ————————————————————————————————————
function updateCountdown() {
  const cd=$('#countdown'), ends=$('#endsIn'); if (!cd) return;
  let diff = countdownEnd - Date.now(); if (diff < 0) diff = 0;
  const d = Math.floor(diff / 86400000);
  const h = Math.floor((diff % 86400000) / 3600000);
  const m = Math.floor((diff % 3600000) / 60000);
  const s = Math.floor((diff % 60000) / 1000);
  const text = `${d}d:${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  cd.textContent = text; if (ends) ends.textContent = text.replace('d',' days ');
}
function initCountdown(){ updateCountdown(); setInterval(updateCountdown, 1000); }

// ——— STARFIELD ————————————————————————————————————
function initStarfield(){ const c=$('#starfield'); if (!c) return; const ctx=c.getContext('2d'); let w,h,stars;
  function resize(){ w=c.width=innerWidth; h=c.height=innerHeight;
    stars=Array.from({length:Math.min(240,Math.floor((w*h)/9000))},()=>({x:Math.random()*w,y:Math.random()*h,z:Math.random()*0.8+0.2,s:Math.random()*1.6+0.2}));
  }
  function tick(){ ctx.clearRect(0,0,w,h);
    for(const st of stars){ st.x+=st.z*0.35; if(st.x>w) st.x=0,st.y=Math.random()*h; ctx.globalAlpha=0.6*st.z+0.2; ctx.fillRect(st.x,st.y,st.s,st.s); }
    requestAnimationFrame(tick);
  }
  addEventListener('resize',resize); resize(); tick();
}

// ——— PHANTOM ——————————————————————————————————————
function getProvider() {
  if (window.phantom?.solana?.isPhantom) return window.phantom.solana;
  if (window.solana?.isPhantom) return window.solana;
  return null;
}
function onPhantomInitialized(cb){
  if (getProvider()) return cb();
  addEventListener('phantom#initialized', cb, { once: true });
  addEventListener('solana#initialized',  cb, { once: true });
  setTimeout(cb, 600);
}

// ——— BACKEND ——————————————————————————————————————
async function postPay(endpoint, body) {
  try {
    const res = await fetch(`${API_URL}/pay/${endpoint}`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body),
    });
    const json = await res.json().catch(() => ({}));
    if (!res.ok || json?.success === false) throw new Error(json?.error || `Server error (${res.status})`);
    return json;
  } catch (error) {
    console.error('Backend request failed:', error);
    throw new Error('Network error: Could not reach server');
  }
}

// ——— PROGRESS ————————————————————————————————————
function animateProgress(){
  const fill=$('#progressFill'), label=$('#progressLabel'), targetEl=$('#targetSupply');
  if (!fill || !label || !targetEl) return;
  if (!TARGET_SUPPLY || TARGET_SUPPLY <= 0) { fill.style.width='0%'; label.textContent='— sold'; targetEl.textContent='—'; return; }
  const pct = Math.max(0, Math.min(100, (soldSoFar / TARGET_SUPPLY) * 100));
  fill.style.width = `${pct}%`;
  label.textContent = `${fmt(soldSoFar)} GC sold (${pct.toFixed(2)}%)`;
  targetEl.textContent = `${fmt(TARGET_SUPPLY)} GC`;
}
async function fetchProgress() {
  try {
    const res = await fetch(`${API_URL}/stats`, { cache: 'no-store' });
    const json = await res.json();
    if (!json.success) throw new Error(json.error || 'Stats fetch failed');
    TARGET_SUPPLY = Number(json.target) || 0;
    soldSoFar     = Number(json.sold)   || 0;
    animateProgress();
  } catch (error) {
    console.error('Progress fetch error:', error);
    TARGET_SUPPLY = 80000000;
    soldSoFar = Math.floor(TARGET_SUPPLY * 0.15);
    animateProgress();
  }
}

// ——— WALLET FLOW ———————————————————————————————————
async function initSol() {
  const btn = $('#btnSolConnect'); if (btn) btn.addEventListener('click', connectSol);
  if (!ensureSecureOrigin()) { if (btn) btn.disabled = true; return; }

  onPhantomInitialized(async () => {
    const provider = getProvider();
    if (!provider) { setStatus('Waiting for Phantom…'); return; }
    try {
      await provider.connect({ onlyIfTrusted: true });
      solProvider = provider;
      solAddress  = provider.publicKey?.toBase58?.();
      if (solAddress) {
        if (btn) btn.innerHTML = '<i class="lucide-badge-check"></i> Phantom Connected';
        const buy=$('#btnBuySol'); if (buy) buy.disabled=false;
        setStatus(`Connected: ${solAddress}`);
        
        // PRE-CREATE CONNECTION to avoid timing issues during purchase
        if (!solConnection && globalThis.solanaWeb3?.Connection) {
          try {
            solConnection = new globalThis.solanaWeb3.Connection(SOLANA_RPC_URL, 'confirmed');
            console.log('[initSol] Pre-created connection successfully');
          } catch (error) {
            console.error('Pre-connection failed:', error);
          }
        }
      }
      provider.on?.('accountChanged', (pk) => {
        solAddress = pk?.toBase58?.() || null;
        if (solAddress) {
          setStatus(`Connected: ${solAddress}`);
        } else {
          setStatus('Wallet disconnected.');
          const buy=$('#btnBuySol'); if (buy) buy.disabled=true;
          if (btn) btn.innerHTML = '<i class="lucide-plug"></i> Connect Phantom';
        }
      });
    } catch (error) {
      console.error('Auto-connect failed:', error);
    }
  });
}

async function connectSol() {
  const btn = $('#btnSolConnect');
  const provider = getProvider();
  if (!provider) {
    alert('Please install Phantom Wallet');
    try { open('https://phantom.com/download','_blank','noopener'); } catch {}
    return;
  }
  try {
    const resp = await provider.connect({ onlyIfTrusted: false });
    solProvider = provider;
    solAddress  = provider.publicKey?.toBase58?.() || resp?.publicKey?.toBase58?.();
    if (btn) btn.innerHTML = '<i class="lucide-badge-check"></i> Phantom Connected';
    const buy=$('#btnBuySol'); if (buy) buy.disabled=false;
    setStatus(`Connected: ${solAddress}`);

    if (!solConnection) {
      await ensureWeb3();
      try {
        solConnection = new globalThis.solanaWeb3.Connection(SOLANA_RPC_URL, 'confirmed');
        console.log('[connectSol] Connection created successfully');
      } catch (error) {
        console.error('Connection creation failed:', error);
        // Create fallback connection if real one fails
        if (globalThis.solanaWeb3?.Connection) {
          solConnection = new globalThis.solanaWeb3.Connection(SOLANA_RPC_URL, 'confirmed');
        }
      }
    }
  } catch (e) {
    console.error('Phantom connect error', e);
    setStatus(`Connect failed: ${e?.message || e}`);
  }
}

async function buySol() {
  const desiredGC = parseFloat($('#solAmount')?.value);
  const status = statusEl();
  if (isNaN(desiredGC) || desiredGC <= 0) { if (status) status.textContent='❌ Enter a valid GC amount.'; return; }
  if (!solProvider?.publicKey)         { if (status) status.textContent='❌ Connect Phantom first.'; return; }

  console.log('[Diag] pre-ensure typeof solanaWeb3 =', typeof globalThis.solanaWeb3);
  console.log('[Diag] solanaWeb3.Transaction =', globalThis.solanaWeb3?.Transaction);

  if (!(await ensureWeb3())) { if (status) status.textContent='❌ Could not load Solana Web3 — check network/CSP.'; return; }
  if (!globalThis.solanaWeb3) { if (status) status.textContent='❌ Web3 module present but global missing.'; return; }
  if (!globalThis.solanaWeb3.Transaction) { if (status) status.textContent='❌ Transaction class not available.'; return; }
  
  // Ensure connection exists with better error handling
  if (!solConnection) { 
    try {
      solConnection = new globalThis.solanaWeb3.Connection(SOLANA_RPC_URL, 'confirmed');
    } catch (error) {
      console.error('Connection creation failed:', error);
      if (status) status.textContent='❌ Failed to create Solana connection.';
      return;
    }
  }

  if (status) status.textContent = '⏳ Fetching SOL price…';
  try {
    const solUsd    = await fetchPrice();
    const usdTotal  = USD_PER_GC * desiredGC;
    const solNeeded = usdTotal / solUsd;
    const lamports  = Math.ceil(solNeeded * globalThis.solanaWeb3.LAMPORTS_PER_SOL);
    if (lamports <= 0) { if (status) status.textContent='❌ Amount too small — try more GC.'; return; }

    if (status) status.textContent = `⏳ Sending ${solNeeded.toFixed(6)} SOL…`;

    const tx = new globalThis.solanaWeb3.Transaction().add(
      globalThis.solanaWeb3.SystemProgram.transfer({
        fromPubkey: solProvider.publicKey,
        toPubkey:   new globalThis.solanaWeb3.PublicKey(RECEIVER_SOL),
        lamports,
      })
    );
    tx.feePayer = solProvider.publicKey;

    // Enhanced error handling for blockhash retrieval
    let blockhash, lastValidBlockHeight;
    try {
      const blockhashData = await solConnection.getLatestBlockhash('confirmed');
      blockhash = blockhashData.blockhash;
      lastValidBlockHeight = blockhashData.lastValidBlockHeight;
      tx.recentBlockhash = blockhash;
    } catch (blockhashError) {
      console.error('Blockhash retrieval failed:', blockhashError);
      if (status) status.textContent='❌ Network error: Could not get latest blockhash.';
      return;
    }

    let signature;
    try {
      if (typeof solProvider.signAndSendTransaction === 'function') {
        const res = await solProvider.signAndSendTransaction(tx);
        signature = res?.signature || res;
      } else {
        const signed = await solProvider.signTransaction(tx);
        signature = await solConnection.sendRawTransaction(signed.serialize());
      }
    } catch (signError) {
      console.error('Transaction signing failed:', signError);
      if (status) status.textContent='❌ Transaction failed: ' + (signError.message || 'User rejected or network error');
      return;
    }

    try {
      await solConnection.confirmTransaction(
        { signature, blockhash, lastValidBlockHeight },
        'confirmed'
      );
    } catch (confirmError) {
      console.warn('Transaction confirmation warning:', confirmError);
      // Continue even if confirmation has issues - the transaction might still succeed
    }

    if (status) status.textContent = '⏳ Finalizing…';
    const resp = await postPay('sol', { txSignature: signature, buyerSol: solAddress, gcAmount: desiredGC });
    if (status) status.textContent = `🎉 Received ${resp.gc} GC — Tx: ${resp.sig}`;
    try { await fetchProgress(); window.confetti?.({ particleCount:120, spread:70, origin:{ y:0.6 } }); } catch {}
  } catch (err) {
    console.error(err);
    if (status) status.textContent = `❌ ${err.message || err}`;
  }
}

// —— Reveal on scroll for tech sections ——
function initReveals(){
  const els = document.querySelectorAll('.reveal');
  const io = new IntersectionObserver((entries)=>{
    entries.forEach(e=>{
      if(e.isIntersecting){ e.target.classList.add('is-visible'); io.unobserve(e.target); }
    });
  }, { rootMargin: '0px 0px -10% 0px', threshold: 0.15 });
  els.forEach(el=>io.observe(el));
}

// ——— UI WIRING ————————————————————————————————————
function initQtyButtons(){ const input=$('#solAmount'); if(!input) return;
  document.querySelectorAll('.chip[data-step]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const step = parseInt(btn.getAttribute('data-step'), 10);
      const v = Math.max(1, (parseInt(input.value || '0', 10) + step));
      input.value = v; updateRateDisplay();
    });
  });
}
function initCopy(){ const btn=$('#btnCopyAddr'), textEl=$('#recvText'); if(!btn||!textEl) return;
  const text=textEl.textContent.trim();
  btn.addEventListener('click', async ()=>{ try{
    await navigator.clipboard.writeText(text);
    btn.innerHTML='<i class="lucide-check"></i> Copied';
    setTimeout(()=> btn.innerHTML='<i class="lucide-clipboard"></i> Copy Receiver',1600);
  }catch(e){ console.error(e);} });
}

// ——— BOOTSTRAP ————————————————————————————————————
window.addEventListener('DOMContentLoaded', async () => {
  initStarfield();
  const y=$('#year'); if (y) y.textContent=new Date().getFullYear();

  try { const p=await fetchPrice(); currentSolUsd=p; const live=$('#liveSolUsd'); if(live) live.textContent=`$${p.toFixed(2)}`; updateRateDisplay(); }
  catch (err) { console.error('Rate fetch failed', err); const rate=$('#rateDisplay'); if (rate) rate.textContent='❌ Rate unavailable'; const live=$('#liveSolUsd'); if (live) live.textContent='—'; }

  const amt=$('#solAmount'); if (amt) amt.addEventListener('input', updateRateDisplay);
  const buy=$('#btnBuySol'); if (buy) buy.addEventListener('click', buySol);
  initQtyButtons(); initCopy();

  initSol();
  try { await fetchProgress(); } catch (e) { console.error(e); }
  setInterval(fetchProgress, 30_000);
  initCountdown();
  initReveals();
});

// ===== Web3-less Solana Pay fallback =====
async function buySolPay() {
  const status = statusEl();
  const desiredGC = parseFloat(document.querySelector('#solAmount')?.value || '0') || 0;
  if (isNaN(desiredGC) || desiredGC <= 0) { if (status) status.textContent = '❌ Enter a valid GC amount.'; return; }
  if (!solProvider?.publicKey) { if (status) status.textContent = '❌ Connect Phantom first.'; return; }

  try {
    if (status) status.textContent = '⏳ Fetching SOL price…';
    const solUsd = await fetchPrice();
    const usdTotal = USD_PER_GC * desiredGC;
    const solNeeded = usdTotal / solUsd;

    // Build Solana Pay transfer URL (wallets understand this)
    const amount = solNeeded.toFixed(9); // 9 decimals
    const url = 'solana:transfer'
      + '?recipient=' + encodeURIComponent(RECEIVER_SOL)
      + '&amount=' + encodeURIComponent(amount)
      + '&label=' + encodeURIComponent('Guaso Presale')
      + '&message=' + encodeURIComponent(`Purchase ${desiredGC} GC`);

    if (status) status.textContent = `🔗 Opening wallet for ${amount} SOL…`;
    try { window.location.href = url; } catch { open(url, '_blank', 'noopener'); }

    // Ask user for the signature after approval
    const sig = prompt('After approving in your wallet, paste the transaction signature here:');
    if (!sig || !sig.trim()) { if (status) status.textContent = '❌ No signature provided.'; return; }

    if (status) status.textContent = '⏳ Verifying payment on-chain…';
    const resp = await postPay('sol', { txSignature: sig.trim(), buyerSol: solAddress, gcAmount: desiredGC });
    if (status) status.textContent = `🎉 Received ${resp.gc} GC — Tx: ${resp.sig}`;
    try { await fetchProgress(); window.confetti?.({ particleCount:120, spread:70, origin:{ y:0.6 } }); } catch {}
  } catch (err) {
    console.error(err);
    if (status) status.textContent = `❌ ${err?.message || err}`;
  }
}
